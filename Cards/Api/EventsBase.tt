<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.Xml" #>
<#@ assembly name="netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51" #>
<#@ import namespace="System.IO" #>


<#
    XmlDocument doc = new();
    // Replace this file path with yours:
    doc.Load(@"./EventDefinitions.xml");

    Generate();

    void Generate()
    {
#>
// ReSharper disable RedundantUsingDirective
// ReSharper disable PossibleNullReferenceException
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantCast
using System;
using System.Collections.Generic;
using System.Reflection;
using Api;

<#
        DirectoryInfo currentDir = new DirectoryInfo(Environment.CurrentDirectory);
        string projectName = currentDir.Name;
        
        string pathToTemplates = $"./../{projectName}-EventTemplates.DotSettings";
        string prefix =
            "<wpf:ResourceDictionary xml:space=\"preserve\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:s=\"clr-namespace:System;assembly=mscorlib\" xmlns:ss=\"urn:shemas-jetbrains-com:settings-storage-xaml\" xmlns:wpf=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\">";
        string postfix = "\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t</wpf:ResourceDictionary>\n\t";

        File.WriteAllText(pathToTemplates, prefix);

        string catalogName = "EventsBase";
        // ReSharper disable PossibleNullReferenceException
        foreach (XmlNode node in doc.SelectNodes("/catalog"))
        {
            catalogName = node.Attributes["name"].Value;
            string inherits = node.Attributes["inherits"].Value;
            string namespaceName = node.Attributes["namespace"].Value;
#>

namespace <#= namespaceName #>{
public abstract class <#= catalogName #> : <#= inherits #>{
<#
            foreach (XmlNode eventNode in node.SelectNodes("event"))
            {
#>    #region Code for event <#= eventNode.Attributes["id"].Value #>
<#
                CreateInvocator(eventNode);
#>    #endregion Code for event <#= eventNode.Attributes["id"].Value #>
<#
            }
        }
#>
}
<#
        foreach (XmlNode node in doc.SelectNodes("/catalog"))
        {
            foreach (XmlNode eventNode in node.SelectNodes("event"))
            {
                CreateAttribute(eventNode);
                CreateEvent(eventNode);
            }
        }

        File.AppendAllText(pathToTemplates, postfix);

        void CreateEvent(XmlNode eventNode)
        {
            File.AppendAllText(pathToTemplates, CreateRiderTemplate(eventNode.Attributes["id"].Value));
            string argsClassName = eventNode.Attributes["id"].Value + "EventArgs";
#>
    //public delegate void <#= eventNode.Attributes["id"].Value #>Event (object sender, <#= argsClassName #> args);

    public class <#= argsClassName #> {<#
            XmlNodeList argnodes = eventNode.SelectNodes("arg");
            XmlNodeList memberNodes = eventNode.SelectNodes("member");
            int argCount = argnodes != null ? argnodes.Count : 0;
            if (argCount > 0)
            {
                foreach (XmlNode argNode in argnodes)
                {
#>
        public  <#=
                        argNode.Attributes["type"].Value #> <#=
                        argNode.Attributes["name"].Value #> { get; }
<#
                }
                foreach (XmlNode argNode in memberNodes)
                {
#>
        public  <#=
                        argNode.Attributes["type"].Value #> <#=
                        argNode.Attributes["name"].Value #> { get; set;} 
<#
                    if (argNode.Attributes["value"]?.Value != null)
                    {
#>=<#=
                            argNode.Attributes["value"].Value #>;<#
                    }
                }
#>
        public  <#= argsClassName #> (<#
                int currentArg = 0;
                foreach (XmlNode argNode in argnodes)
                {
                    currentArg++;

                    string argPostfix = "";
                    if (currentArg != argCount)
                    {
                        //add comma between arguments
                        argPostfix = ",";
                    }
#><#= argNode.Attributes["type"].Value #> <#=
                        argNode.Attributes["name"].Value + argPostfix #> <#
                }
#>
  ){
    <#
                foreach (XmlNode argNode in argnodes)
                {
//set in ctor
#>
              this.<#=
                        argNode.Attributes["name"].Value #> = <#=
                        argNode.Attributes["name"].Value #>; 
<#
                }
#>
}

<#
            }
#>
        }<#
        }
#>


<#
        void CreateAttribute(XmlNode eventNode)
        {
#>
/// <summary>
/// (object sender, <#= eventNode.Attributes["id"].Value #>EventArgs) args)
/// </summary>
public class On<#= eventNode.Attributes["id"].Value #>Attribute : EventsBaseAttribute {
    public override IDisposable GetEventHandle(MethodInfo attached, IEventfulComponent instance, EventsBase events)
    {
        instance.EventEntrance.Add(Id, 0);
        var parameters = attached.GetParameters();
        if (parameters.Length == 0)
        {
            return ((<#= catalogName #>)events).SubscribeTo<#= eventNode.Attributes["id"].Value #>(delegate
            {
                if(!instance.Enabled){
                    return;
                }
                if(instance.EventEntrance[Id] > 0){
                    Logging.Log($"Preventing re-entrancy on event {Id} for component {instance.GetType()}.");
                    return;
                }
                instance.EventEntrance[Id]++;
                attached.Invoke(instance, Array.Empty<object>());
                instance.EventEntrance[Id]--;
            });
        }
        if(parameters[0].ParameterType != typeof(object) ||
        parameters[1].ParameterType != typeof(<#= eventNode.Attributes["id"].Value #>EventArgs)){
            throw new NotSupportedException("Wrong parameters for attribute usage! must match signature (object sender, <#= eventNode.Attributes["id"].Value #>EventArgs) args)");
        }
        return ((<#= catalogName #>)events).SubscribeTo<#= eventNode.Attributes["id"].Value #>(delegate(object sender, <#= eventNode.Attributes["id"].Value #>EventArgs args)
        {
            if(!instance.Enabled){
                return;
            }
            if(instance.EventEntrance[Id] > 0){
                Logging.Log($"Preventing re-entrancy on event {Id} for component {instance.GetType()}.");
                return;
            }
            instance.EventEntrance[Id]++;
            attached.Invoke(instance, new[] { sender, args });
            instance.EventEntrance[Id]--;
        });
    }


}
<#
        }

        void CreateInvocator(XmlNode eventNode)
        {
            string eventName = eventNode.Attributes["id"].Value;
            string argsName = eventNode.Attributes["id"].Value + "EventArgs";
            string eventTypeName = $"EventHandleDelegate<{argsName}>";
#>
private event <#= eventTypeName #> <#= eventName #>;
public virtual void On<#= eventName #>(<#= argsName #> args)
{
    <#= eventName #>?.Invoke(this, args);
}

public EventHandle<<#= argsName #>> SubscribeTo<#= eventName #>(EventHandleDelegate<<#= argsName #>> action)
{
    var handler = new EventHandle<<#= argsName #>>(action, () => <#= eventName #> -= action);
    <#= eventName #> += handler.Invoke;
    return handler;
} 
<#
        }
#>



 }

    
<#
        string CreateRiderTemplate(string eventName)
        {
            string guid = Guid.NewGuid().ToString();
            guid = guid.Replace("-", "");
            guid = guid.ToUpper();
            string template =
                @$"
     <s:Boolean x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/@KeyIndexDefined"">True</s:Boolean>
    <s:Boolean x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Applicability/=Live/@EntryIndexedValue"">True</s:Boolean>
    <s:Boolean x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Reformat/@EntryValue"">True</s:Boolean>
    <s:Boolean x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Scope/=C3001E7C0DA78E4487072B7E050D86C5/@KeyIndexDefined"">True</s:Boolean>
    <s:String x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Scope/=C3001E7C0DA78E4487072B7E050D86C5/CustomProperties/=minimumLanguageVersion/@EntryIndexedValue"">2.0</s:String>
    <s:String x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Scope/=C3001E7C0DA78E4487072B7E050D86C5/Type/@EntryValue"">InCSharpFile</s:String>
    <s:String x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Shortcut/@EntryValue"">On{eventName}</s:String>
    <s:Boolean x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/ShortenQualifiedReferences/@EntryValue"">True</s:Boolean>
                        <s:String x:Key=""/Default/PatternsAndTemplates/LiveTemplates/Template/={guid}/Text/@EntryValue"">[On{eventName}]
                        private void On{eventName}(object sender, {eventName}EventArgs args){{
                        $END$
                    }}</s:String>";

            return template;
        }
    }
#>

 
